#ifndef PSCRIPT_TOKEN_TYPE_H
#define PSCRIPT_TOKEN_TYPE_H

// RL: All those tokens should be ordered by priorities: 
//     the lowest priority first, the highest priority last. 
enum { 
  PSCRIPT_TOKEN_NULL, 
  PSCRIPT_TOKEN_EOF, 
  // RL: Syntatic sugar // Very low priority, i.e. outmost nodes  
  PSCRIPT_TOKEN_OF, 
  PSCRIPT_TOKEN_TO, 
  PSCRIPT_TOKEN_DOWNTO, 
  PSCRIPT_TOKEN_STEP, 
  PSCRIPT_TOKEN_PTVIRG, 
  PSCRIPT_TOKEN_OPENPAR, 
  PSCRIPT_TOKEN_CLOSEPAR, 
  PSCRIPT_TOKEN_OPENBRACKET, 
  PSCRIPT_TOKEN_CLOSEBRACKET, 
  PSCRIPT_TOKEN_OPENBRACE, 
  PSCRIPT_TOKEN_CLOSEBRACE, 
  PSCRIPT_TOKEN_DEUXPOINTS, 
  PSCRIPT_TOKEN_VIRGULE, 
  PSCRIPT_TOKEN_AS, 
  PSCRIPT_TOKEN_HUH, 
  // RL: EXPR 
  PSCRIPT_TOKEN_AFFECTATION, 
  PSCRIPT_TOKEN_AFFECTATION_SIMPLE, 
  PSCRIPT_TOKEN_AFFECTATION_IADD, 
  PSCRIPT_TOKEN_AFFECTATION_RADD, 
  PSCRIPT_TOKEN_AFFECTATION_ISUB, 
  PSCRIPT_TOKEN_AFFECTATION_RSUB, 
  PSCRIPT_TOKEN_AFFECTATION_IMULT, 
  PSCRIPT_TOKEN_AFFECTATION_RMULT, 
  PSCRIPT_TOKEN_AFFECTATION_IDIV, 
  PSCRIPT_TOKEN_AFFECTATION_RDIV, 
  PSCRIPT_TOKEN_AFFECTATION_IMOD, 
  PSCRIPT_TOKEN_AFFECTATION_L_AND, 
  PSCRIPT_TOKEN_AFFECTATION_L_OR, 
  PSCRIPT_TOKEN_AFFECTATION_L_XOR, 
  PSCRIPT_TOKEN_AFFECTATION_L_NOT, 
  PSCRIPT_TOKEN_AFFECTATION_B_AND, 
  PSCRIPT_TOKEN_AFFECTATION_B_OR, 
  PSCRIPT_TOKEN_AFFECTATION_B_XOR, 
  PSCRIPT_TOKEN_AFFECTATION_B_NOT, 
  PSCRIPT_TOKEN_AFFECTATION_B_RSHIFT, 
  PSCRIPT_TOKEN_AFFECTATION_B_LSHIFT, 
  PSCRIPT_TOKEN_LOGICAL_AND, 
  PSCRIPT_TOKEN_LOGICAL_OR, 
  PSCRIPT_TOKEN_LOGICAL_XOR, // RL: BITWISE_XOR is definitely different. 
  PSCRIPT_TOKEN_LOGICAL_NOT, 
  PSCRIPT_TOKEN_EQUAL, // RL: The question is the interpretation of "a == b and d != e". 
  PSCRIPT_TOKEN_DIFF, 
  PSCRIPT_TOKEN_INF, // RL: The question is the interpretation of "a < b and d >= e". 
  PSCRIPT_TOKEN_SUP, 
  PSCRIPT_TOKEN_INFEQ, 
  PSCRIPT_TOKEN_SUPEQ, 
  PSCRIPT_TOKEN_IDIV, // RL: This thing has definitely a low priority: "1 + 2 div 4 + 3" 
  PSCRIPT_TOKEN_IMOD, 
  PSCRIPT_TOKEN_BITWISE_AND, 
  PSCRIPT_TOKEN_BITWISE_OR, 
  PSCRIPT_TOKEN_BITWISE_XOR, // RL: BOOL_XOR is definitely different. 
  PSCRIPT_TOKEN_BITWISE_NOT, 
  PSCRIPT_TOKEN_BITWISE_SHIFT_LEFT, 
  PSCRIPT_TOKEN_BITWISE_SHIFT_RIGHT, 
  PSCRIPT_TOKEN_IPLUS, 
  PSCRIPT_TOKEN_RPLUS, 
  PSCRIPT_TOKEN_IMOINS, 
  PSCRIPT_TOKEN_RMOINS, 
  PSCRIPT_TOKEN_IMULT, 
  PSCRIPT_TOKEN_RMULT, 
  PSCRIPT_TOKEN_RDIV, 
  PSCRIPT_TOKEN_POINT, 
  PSCRIPT_TOKEN_FLECHE, 
  PSCRIPT_TOKEN_PTR, 
  PSCRIPT_TOKEN_REF, 
  PSCRIPT_TOKEN_INC, 
  PSCRIPT_TOKEN_DEC, 
  // RL: Constant values, which have the upmost priorities 
  PSCRIPT_TOKEN_TRUE, 
  PSCRIPT_TOKEN_FALSE, 
  PSCRIPT_TOKEN_ENTIER, 
  PSCRIPT_TOKEN_REEL__VIRG, 
  PSCRIPT_TOKEN_REEL__DOT, 
  PSCRIPT_TOKEN_REEL__E, 
  PSCRIPT_TOKEN_STRING_C, 
  PSCRIPT_TOKEN_STRING_C__EOL, 
  PSCRIPT_TOKEN_STRING_C__EOF, 
  PSCRIPT_TOKEN_STRING_P, 
  PSCRIPT_TOKEN_STRING_P__EOL, 
  PSCRIPT_TOKEN_STRING_P__EOF, 
  PSCRIPT_TOKEN_NIL, 
  PSCRIPT_TOKEN_NULL_PTR, 
  // RL: LL(1) type 
  PSCRIPT_TOKEN_TYPE, 
  PSCRIPT_TOKEN_TYPE_ALIAS, 
  PSCRIPT_TOKEN_BOOLEAN, 
  PSCRIPT_TOKEN_INTEGER, 
  PSCRIPT_TOKEN_FLOAT, 
  PSCRIPT_TOKEN_STRING, 
  PSCRIPT_TOKEN_SUBRANGE, 
  PSCRIPT_TOKEN_ARRAY, 
  PSCRIPT_TOKEN_RECORD, 
  PSCRIPT_TOKEN_VARIANT, 
  // RL: LL(1) control flow 
  PSCRIPT_TOKEN_IF, 
  PSCRIPT_TOKEN_WHEN, 
  PSCRIPT_TOKEN_UNLESS, 
  PSCRIPT_TOKEN_WHILE, 
  PSCRIPT_TOKEN_FOR, 
  PSCRIPT_TOKEN_REPEAT, 
  PSCRIPT_TOKEN_BEGIN, 
  PSCRIPT_TOKEN_PROCEDURE, 
  PSCRIPT_TOKEN_FONCTION, 
  PSCRIPT_TOKEN_METHODE, 
  PSCRIPT_TOKEN_LAMBDA, 
  PSCRIPT_TOKEN_CONST, 
  PSCRIPT_TOKEN_VAR, 
  //PSCRIPT_TOKEN_REC, // RL: Needless. 'This' is not a token as well. 
  // RL: control flow others 
  PSCRIPT_TOKEN_DONE, 
  PSCRIPT_TOKEN_DO, 
  PSCRIPT_TOKEN_THEN, 
  PSCRIPT_TOKEN_ELSE, 
  PSCRIPT_TOKEN_FI, 
  PSCRIPT_TOKEN_UNTIL, 
  PSCRIPT_TOKEN_END, 
  // RL: Other qualifying keywords 
  PSCRIPT_TOKEN_BYREF, 
  PSCRIPT_TOKEN_BYVAL, 
  // RL: Ident 
  PSCRIPT_TOKEN_SYNTAX_MASTER, 
  PSCRIPT_TOKEN_SYNTAX_KEYWORD, // RL: Could be handled like a regular ident by the parser? 
  PSCRIPT_TOKEN_IDENT, 
  // RL: Ignored tokens 
  PSCRIPT_TOKEN_EOL, 
  PSCRIPT_TOKEN_BLANC, 
  PSCRIPT_TOKEN_COMMENT__ONE_LINE_CPP, 
  PSCRIPT_TOKEN_COMMENT__ONE_LINE_SCRIPT, 
  PSCRIPT_TOKEN_COMMENT__MULTI_LINES_C_STYLE, 
  PSCRIPT_TOKEN_COMMENT__MULTI_LINES_C_STYLE__EOF, 
  PSCRIPT_TOKEN_COMMENT__MULTI_LINES_C_STYLE__LONELY_ENDING, 
  PSCRIPT_TOKEN_COUNT  
}; 

enum { PSCRIPT_TOKEN__SYNTAX_MASTER__BASE  = PSCRIPT_TOKEN_COUNT }; 
enum { PSCRIPT_TOKEN__SYNTAX_MASTER__SIZE  = 16 }; 
enum { PSCRIPT_TOKEN__SYNTAX_MASTER__TOP   = PSCRIPT_TOKEN__SYNTAX_MASTER__BASE + PSCRIPT_TOKEN__SYNTAX_MASTER__SIZE }; 

enum { PSCRIPT_TOKEN__SYNTAX_KEYWORD__BASE = PSCRIPT_TOKEN__SYNTAX_MASTER__TOP }; 
enum { PSCRIPT_TOKEN__SYNTAX_KEYWORD__SIZE = 16 }; 
enum { PSCRIPT_TOKEN__SYNTAX_KEYWORD__TOP  = PSCRIPT_TOKEN__SYNTAX_KEYWORD__BASE + PSCRIPT_TOKEN__SYNTAX_KEYWORD__SIZE }; 

extern const int8_t pscript_token_count; 

//#define TOKEN_MAX PSCRIPT_TOKEN_COUNT 
enum { TOKEN_MAX = PSCRIPT_TOKEN__SYNTAX_KEYWORD__TOP }; 



 
// RL: Token aliases. 
enum { 
  PSCRIPT_TOKEN_ASSIGN        = PSCRIPT_TOKEN_AFFECTATION, 
  PSCRIPT_TOKEN_METHOD        = PSCRIPT_TOKEN_METHODE, 
  PSCRIPT_TOKEN_COMMA         = PSCRIPT_TOKEN_VIRGULE, 
  PSCRIPT_TOKEN_COLON         = PSCRIPT_TOKEN_DEUXPOINTS, 
  PSCRIPT_TOKEN_SEMICOLON     = PSCRIPT_TOKEN_PTVIRG, 
  PSCRIPT_TOKEN_POINTVIRGULE  = PSCRIPT_TOKEN_PTVIRG, 
  PSCRIPT_TOKEN_POINT_VIRGULE = PSCRIPT_TOKEN_PTVIRG, 
  PSCRIPT_TOKEN_FUNCTION      = PSCRIPT_TOKEN_FONCTION, 
  PSCRIPT_TOKEN_IMINUS        = PSCRIPT_TOKEN_IMOINS, 
  PSCRIPT_TOKEN_RMINUS        = PSCRIPT_TOKEN_RMOINS, 
  PSCRIPT_TOKEN_DOT           = PSCRIPT_TOKEN_POINT, 
  PSCRIPT_TOKEN_ARROW         = PSCRIPT_TOKEN_FLECHE, 
  PSCRIPT_TOKEN_CHAINE_C      = PSCRIPT_TOKEN_STRING_C, 
  PSCRIPT_TOKEN_CHAINE_P      = PSCRIPT_TOKEN_STRING_P, 
  PSCRIPT_TOKEN_REAL          = PSCRIPT_TOKEN_FLOAT, 
}; 

//extern const char * pscript_token__type_cstr_array[]; 

extern const char * pscript_token__type_get_cstr(const uint8_t token_type); 
#define pscript_token__type_cstr pscript_token__type_get_cstr

typedef       uint8_t                   int_pscript_token_type_t; 
extern  const int_pscript_token_type_t  int_pscript_token_type_max; // RL: Use for storage, where data should be packed. Anywhere else, 'int' is good. The property ensures that a token_type will fit into a 'int_pscript_token_type_t'. 


#endif /* PSCRIPT_TOKEN_TYPE_H */

